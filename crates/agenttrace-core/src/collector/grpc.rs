//! gRPC server for span ingestion
//!
//! Provides a gRPC endpoint compatible with OpenTelemetry-style span submission.

use std::sync::Arc;

use chrono::{DateTime, TimeZone, Utc};
use tonic::{Request, Response, Status};
use tracing::{debug, info};
use uuid::Uuid;

use crate::error::Result;
use crate::models::{Span, SpanEvent, SpanKind, SpanStatus};

use super::Pipeline;

/// gRPC server for the collector
pub struct GrpcServer {
    pipeline: Arc<Pipeline>,
}

impl GrpcServer {
    /// Create a new gRPC server
    pub fn new(pipeline: Arc<Pipeline>) -> Self {
        Self { pipeline }
    }

    /// Start serving on the given address
    pub async fn serve(self, addr: &str) -> Result<()> {
        let addr = addr.parse().map_err(|e| {
            crate::error::Error::Config(format!("Invalid address: {}", e))
        })?;

        info!("gRPC server listening on {}", addr);

        // Create the service
        let service = CollectorServiceImpl {
            pipeline: self.pipeline,
        };

        tonic::transport::Server::builder()
            .add_service(CollectorServer::new(service))
            .serve(addr)
            .await
            .map_err(|e| crate::error::Error::Grpc(e.to_string()))?;

        Ok(())
    }
}

// Define the gRPC service traits manually since we don't have proto compilation yet
// In production, these would be generated by tonic-build from the proto file

/// Request to send a span
#[derive(Debug, Clone)]
pub struct SendSpanRequest {
    pub span_id: String,
    pub trace_id: String,
    pub parent_span_id: Option<String>,
    pub operation_name: String,
    pub service_name: String,
    pub start_time_unix_nano: i64,
    pub end_time_unix_nano: Option<i64>,
    pub status: i32,
    pub status_message: Option<String>,
    pub model_name: Option<String>,
    pub model_provider: Option<String>,
    pub tokens_in: Option<i32>,
    pub tokens_out: Option<i32>,
    pub tokens_reasoning: Option<i32>,
    pub tool_name: Option<String>,
    pub tool_input: Option<String>,
    pub tool_output: Option<String>,
    pub prompt_preview: Option<String>,
    pub completion_preview: Option<String>,
    pub attributes: Option<String>, // JSON string
    pub events: Vec<SpanEventProto>,
}

#[derive(Debug, Clone)]
pub struct SpanEventProto {
    pub name: String,
    pub timestamp_unix_nano: i64,
    pub attributes: Option<String>,
}

#[derive(Debug, Clone)]
pub struct SendSpanResponse {
    pub success: bool,
    pub span_id: String,
}

#[derive(Debug, Clone)]
pub struct SendBatchRequest {
    pub spans: Vec<SendSpanRequest>,
}

#[derive(Debug, Clone)]
pub struct SendBatchResponse {
    pub accepted: i32,
    pub rejected: i32,
}

#[derive(Debug, Clone)]
pub struct HealthRequest {}

#[derive(Debug, Clone)]
pub struct HealthResponse {
    pub healthy: bool,
    pub version: String,
}

/// The collector gRPC service implementation
struct CollectorServiceImpl {
    pipeline: Arc<Pipeline>,
}

impl CollectorServiceImpl {
    fn convert_span(&self, req: SendSpanRequest) -> Span {
        let started_at = nanos_to_datetime(req.start_time_unix_nano);
        let ended_at = req.end_time_unix_nano.map(nanos_to_datetime);

        let status = match req.status {
            0 => SpanStatus::Unset,
            1 => SpanStatus::Ok,
            2 => SpanStatus::Error,
            _ => SpanStatus::Unset,
        };

        let attributes: serde_json::Value = req
            .attributes
            .as_ref()
            .and_then(|s| serde_json::from_str(s).ok())
            .unwrap_or_else(|| serde_json::json!({}));

        let tool_input: Option<serde_json::Value> = req
            .tool_input
            .as_ref()
            .and_then(|s| serde_json::from_str(s).ok());

        let tool_output: Option<serde_json::Value> = req
            .tool_output
            .as_ref()
            .and_then(|s| serde_json::from_str(s).ok());

        let events: Vec<SpanEvent> = req
            .events
            .into_iter()
            .map(|e| SpanEvent {
                name: e.name,
                timestamp: nanos_to_datetime(e.timestamp_unix_nano),
                attributes: e
                    .attributes
                    .and_then(|s| serde_json::from_str(&s).ok())
                    .unwrap_or_else(|| serde_json::json!({})),
            })
            .collect();

        Span {
            id: Uuid::new_v4(),
            span_id: req.span_id,
            trace_id: req.trace_id,
            parent_span_id: req.parent_span_id,
            operation_name: req.operation_name,
            service_name: req.service_name,
            span_kind: SpanKind::Internal,
            started_at,
            ended_at,
            duration_ms: None, // Will be calculated by pipeline
            status,
            status_message: req.status_message,
            model_name: req.model_name,
            model_provider: req.model_provider,
            tokens_in: req.tokens_in,
            tokens_out: req.tokens_out,
            tokens_reasoning: req.tokens_reasoning,
            cost_usd: None, // Will be calculated by pipeline
            tool_name: req.tool_name,
            tool_input,
            tool_output,
            tool_duration_ms: None,
            prompt_preview: req.prompt_preview,
            completion_preview: req.completion_preview,
            attributes,
            events,
            links: vec![],
        }
    }
}

// Manual gRPC service implementation
// In production, this would be generated by tonic-build

#[tonic::async_trait]
trait Collector: Send + Sync + 'static {
    async fn send_span(
        &self,
        request: Request<SendSpanRequest>,
    ) -> std::result::Result<Response<SendSpanResponse>, Status>;

    async fn send_batch(
        &self,
        request: Request<SendBatchRequest>,
    ) -> std::result::Result<Response<SendBatchResponse>, Status>;

    async fn health(
        &self,
        request: Request<HealthRequest>,
    ) -> std::result::Result<Response<HealthResponse>, Status>;
}

#[tonic::async_trait]
impl Collector for CollectorServiceImpl {
    async fn send_span(
        &self,
        request: Request<SendSpanRequest>,
    ) -> std::result::Result<Response<SendSpanResponse>, Status> {
        let req = request.into_inner();
        let span_id = req.span_id.clone();

        debug!("Received span: {}", span_id);

        let span = self.convert_span(req);

        match self.pipeline.submit(span).await {
            Ok(()) => Ok(Response::new(SendSpanResponse {
                success: true,
                span_id,
            })),
            Err(e) => {
                tracing::error!("Failed to submit span: {}", e);
                Err(Status::internal(format!("Failed to submit span: {}", e)))
            }
        }
    }

    async fn send_batch(
        &self,
        request: Request<SendBatchRequest>,
    ) -> std::result::Result<Response<SendBatchResponse>, Status> {
        let req = request.into_inner();
        let total = req.spans.len() as i32;

        debug!("Received batch of {} spans", total);

        let spans: Vec<Span> = req
            .spans
            .into_iter()
            .map(|s| self.convert_span(s))
            .collect();

        match self.pipeline.submit_batch(spans).await {
            Ok(accepted) => Ok(Response::new(SendBatchResponse {
                accepted: accepted as i32,
                rejected: total - accepted as i32,
            })),
            Err(e) => {
                tracing::error!("Failed to submit batch: {}", e);
                Err(Status::internal(format!("Failed to submit batch: {}", e)))
            }
        }
    }

    async fn health(
        &self,
        _request: Request<HealthRequest>,
    ) -> std::result::Result<Response<HealthResponse>, Status> {
        Ok(Response::new(HealthResponse {
            healthy: true,
            version: env!("CARGO_PKG_VERSION").to_string(),
        }))
    }
}

/// Convert nanoseconds since Unix epoch to DateTime
fn nanos_to_datetime(nanos: i64) -> DateTime<Utc> {
    let secs = nanos / 1_000_000_000;
    let nsecs = (nanos % 1_000_000_000) as u32;
    Utc.timestamp_opt(secs, nsecs).unwrap()
}

// Tonic server wrapper
// This is a simplified implementation. In production, use tonic-build to generate from proto.

use tonic::codegen::*;

#[derive(Debug)]
pub struct CollectorServer<T: Collector> {
    inner: Arc<T>,
}

impl<T: Collector> CollectorServer<T> {
    pub fn new(inner: T) -> Self {
        Self {
            inner: Arc::new(inner),
        }
    }
}

impl<T, B> tonic::codegen::Service<http::Request<B>> for CollectorServer<T>
where
    T: Collector,
    B: Body + Send + 'static,
    B::Error: Into<StdError> + Send + 'static,
{
    type Response = http::Response<tonic::body::BoxBody>;
    type Error = std::convert::Infallible;
    type Future = BoxFuture<Self::Response, Self::Error>;

    fn poll_ready(
        &mut self,
        _cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<std::result::Result<(), Self::Error>> {
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: http::Request<B>) -> Self::Future {
        let inner = self.inner.clone();

        // Simple routing based on path
        let path = req.uri().path().to_string();

        Box::pin(async move {
            let response = match path.as_str() {
                "/agenttrace.v1.Collector/Health" => {
                    // Return a simple health response
                    let resp = HealthResponse {
                        healthy: true,
                        version: env!("CARGO_PKG_VERSION").to_string(),
                    };
                    let body = serde_json::to_vec(&resp).unwrap_or_default();
                    http::Response::builder()
                        .status(200)
                        .header("content-type", "application/json")
                        .body(tonic::body::BoxBody::default())
                        .unwrap()
                }
                _ => {
                    // For other paths, return a basic response
                    // In production, properly decode protobuf and route
                    http::Response::builder()
                        .status(200)
                        .body(tonic::body::BoxBody::default())
                        .unwrap()
                }
            };

            Ok(response)
        })
    }
}

impl<T: Collector> tonic::server::NamedService for CollectorServer<T> {
    const NAME: &'static str = "agenttrace.v1.Collector";
}
